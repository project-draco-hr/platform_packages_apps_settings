{
switch (v.getId()) {
case R.id.ok:
{
      final String pin=mPasswordTextView.getText().toString();
      if (TextUtils.isEmpty(pin)) {
        break;
      }
      String errorMsg=null;
      if (mUiStage == Stage.Introduction) {
        errorMsg=validatePassword(pin);
        if (errorMsg == null) {
          mFirstPin=pin;
          updateStage(Stage.NeedToConfirm);
        }
      }
 else       if (mUiStage == Stage.NeedToConfirm) {
        if (mFirstPin.equals(pin)) {
          mLockPatternUtils.setLockPatternEnabled(false);
          mLockPatternUtils.saveLockPattern(null);
          mLockPatternUtils.saveLockPassword(pin,mRequestedMode);
          finish();
        }
 else {
          int msg=R.string.lockpassword_confirm_passwords_dont_match;
          errorMsg=getString(msg);
        }
      }
      if (errorMsg != null) {
        showError(errorMsg,Stage.Introduction);
      }
    }
  break;
case R.id.backspace:
{
  final Editable digits=mPasswordTextView.getEditableText();
  final int len=digits.length();
  if (len > 0) {
    digits.delete(len - 1,len);
  }
}
break;
case R.id.cancel:
finish();
break;
default :
for (int i=0; i < digitIds.length; i++) {
if (v.getId() == digitIds[i]) {
mPasswordTextView.append(Integer.toString(i));
return;
}
}
break;
}
}
