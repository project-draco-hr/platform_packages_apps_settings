{
  final CycleItem previousItem=(CycleItem)mCycleSpinner.getSelectedItem();
  mCycleAdapter.clear();
  final Context context=mCycleSpinner.getContext();
  long historyStart=Long.MAX_VALUE;
  long historyEnd=Long.MIN_VALUE;
  if (mChartData != null) {
    historyStart=mChartData.network.getStart();
    historyEnd=mChartData.network.getEnd();
  }
  final long now=System.currentTimeMillis();
  if (historyStart == Long.MAX_VALUE)   historyStart=now;
  if (historyEnd == Long.MIN_VALUE)   historyEnd=now + 1;
  boolean hasCycles=false;
  if (policy != null) {
    long cycleEnd=computeNextCycleBoundary(historyEnd,policy);
    while (cycleEnd > historyStart) {
      final long cycleStart=computeLastCycleBoundary(cycleEnd,policy);
      Log.d(TAG,"generating cs=" + cycleStart + " to ce="+ cycleEnd+ " waiting for hs="+ historyStart);
      mCycleAdapter.add(new CycleItem(context,cycleStart,cycleEnd));
      cycleEnd=cycleStart;
      hasCycles=true;
    }
    mCycleAdapter.setChangePossible(isNetworkPolicyModifiable(policy));
  }
  if (!hasCycles) {
    long cycleEnd=historyEnd;
    while (cycleEnd > historyStart) {
      final long cycleStart=cycleEnd - (DateUtils.WEEK_IN_MILLIS * 4);
      mCycleAdapter.add(new CycleItem(context,cycleStart,cycleEnd));
      cycleEnd=cycleStart;
    }
    mCycleAdapter.setChangePossible(false);
  }
  if (mCycleAdapter.getCount() > 0) {
    final int position=mCycleAdapter.findNearestPosition(previousItem);
    mCycleSpinner.setSelection(position);
    final CycleItem selectedItem=mCycleAdapter.getItem(position);
    if (!Objects.equal(selectedItem,previousItem)) {
      mCycleListener.onItemSelected(mCycleSpinner,null,position,0);
    }
 else {
      updateDetailData();
    }
  }
 else {
    updateDetailData();
  }
}
