{
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mNeedDivider=false;
        pi.addDependentProcesses(newItems,mProcessItems);
        newItems.add(pi);
        if (pi.mPid > 0) {
          mProcessItems.add(pi);
        }
        boolean needDivider=false;
        for (        ServiceItem si : pi.mServices.values()) {
          si.mNeedDivider=needDivider;
          needDivider=true;
          newItems.add(si);
        }
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,"Unknown non-service process: " + proc.mProcessName + " #"+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}
