{
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mSize=0;
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
      proc.mSize=0;
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  mNumBackgroundProcesses=0;
  mNumForegroundProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        mNumBackgroundProcesses++;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        mNumForegroundProcesses++;
      }
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        changed|=pi.updateSize(context);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    mItems.clear();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mNeedDivider=false;
        pi.addDependentProcesses(mItems);
        mItems.add(pi);
        boolean needDivider=false;
        for (        ServiceItem si : pi.mServices.values()) {
          si.mNeedDivider=needDivider;
          needDivider=true;
          mItems.add(si);
        }
      }
    }
  }
  return changed;
}
