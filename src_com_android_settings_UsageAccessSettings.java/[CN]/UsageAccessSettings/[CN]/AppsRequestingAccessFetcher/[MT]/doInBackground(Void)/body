{
  final String[] packages;
  SparseArray<ArrayMap<String,PackageEntry>> entries;
  try {
    packages=mIPackageManager.getAppOpPermissionPackages(Manifest.permission.PACKAGE_USAGE_STATS);
    if (packages == null) {
      return null;
    }
    entries=new SparseArray<>();
    for (    final UserHandle profile : mProfiles) {
      final ArrayMap<String,PackageEntry> entriesForProfile=new ArrayMap<>();
      final int profileId=profile.getIdentifier();
      entries.put(profileId,entriesForProfile);
      for (      final String packageName : packages) {
        final boolean isAvailable=mIPackageManager.isPackageAvailable(packageName,profileId);
        if (!shouldIgnorePackage(packageName) && isAvailable) {
          final PackageEntry newEntry=new PackageEntry(packageName,profile);
          entriesForProfile.put(packageName,newEntry);
        }
      }
    }
  }
 catch (  RemoteException e) {
    Log.w(TAG,"PackageManager is dead. Can't get list of packages requesting " + Manifest.permission.PACKAGE_USAGE_STATS);
    return null;
  }
  try {
    for (    final UserHandle profile : mProfiles) {
      final int profileId=profile.getIdentifier();
      final ArrayMap<String,PackageEntry> entriesForProfile=entries.get(profileId);
      if (entriesForProfile == null) {
        continue;
      }
      final List<PackageInfo> packageInfos=mIPackageManager.getPackagesHoldingPermissions(PM_USAGE_STATS_PERMISSION,0,profileId).getList();
      final int packageInfoCount=packageInfos != null ? packageInfos.size() : 0;
      for (int i=0; i < packageInfoCount; i++) {
        final PackageInfo packageInfo=packageInfos.get(i);
        final PackageEntry pe=entriesForProfile.get(packageInfo.packageName);
        if (pe != null) {
          pe.packageInfo=packageInfo;
          pe.permissionGranted=true;
        }
      }
    }
  }
 catch (  RemoteException e) {
    Log.w(TAG,"PackageManager is dead. Can't get list of packages granted " + Manifest.permission.PACKAGE_USAGE_STATS);
    return null;
  }
  for (  final UserHandle profile : mProfiles) {
    final int profileId=profile.getIdentifier();
    final ArrayMap<String,PackageEntry> entriesForProfile=entries.get(profileId);
    if (entriesForProfile == null) {
      continue;
    }
    int packageCount=entriesForProfile.size();
    for (int i=packageCount - 1; i >= 0; --i) {
      final PackageEntry pe=entriesForProfile.valueAt(i);
      if (pe.packageInfo == null) {
        try {
          pe.packageInfo=mIPackageManager.getPackageInfo(pe.packageName,0,profileId);
        }
 catch (        RemoteException e) {
          entriesForProfile.removeAt(i);
        }
      }
    }
  }
  final List<AppOpsManager.PackageOps> packageOps=mAppOpsManager.getPackagesForOps(APP_OPS_OP_CODES);
  final int packageOpsCount=packageOps != null ? packageOps.size() : 0;
  for (int i=0; i < packageOpsCount; i++) {
    final AppOpsManager.PackageOps packageOp=packageOps.get(i);
    final int userId=UserHandle.getUserId(packageOp.getUid());
    if (!isThisUserAProfileOfCurrentUser(userId)) {
      continue;
    }
    final ArrayMap<String,PackageEntry> entriesForProfile=entries.get(userId);
    if (entriesForProfile == null) {
      continue;
    }
    final PackageEntry pe=entriesForProfile.get(packageOp.getPackageName());
    if (pe == null) {
      Log.w(TAG,"AppOp permission exists for package " + packageOp.getPackageName() + " of user "+ userId+ " but package doesn't exist or did not request UsageStats access");
      continue;
    }
    if (packageOp.getOps().size() < 1) {
      Log.w(TAG,"No AppOps permission exists for package " + packageOp.getPackageName());
      continue;
    }
    pe.appOpMode=packageOp.getOps().get(0).getMode();
  }
  return entries;
}
