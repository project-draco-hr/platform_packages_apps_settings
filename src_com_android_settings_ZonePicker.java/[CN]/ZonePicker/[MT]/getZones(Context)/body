{
  final Locale locale=Locale.getDefault();
  final Date now=new Date();
  List<String> olsonIdsToDisplay=readTimezonesToDisplay(context);
  Set<String> localZoneIds=new TreeSet<String>();
  for (  String olsonId : TimeZoneNames.forLocale(locale)) {
    localZoneIds.add(olsonId);
  }
  Set<String> localZoneNames=new TreeSet<String>();
  boolean localLongNamesAreAmbiguous=false;
  for (  String olsonId : olsonIdsToDisplay) {
    if (localZoneIds.contains(olsonId)) {
      TimeZone tz=TimeZone.getTimeZone(olsonId);
      String zoneLongName=DateTimeSettings.getZoneLongName(locale,tz,now);
      boolean longNameIsUnique=localZoneNames.add(zoneLongName);
      if (!longNameIsUnique) {
        localLongNamesAreAmbiguous=true;
        break;
      }
    }
  }
  List<Map<String,Object>> zones=new ArrayList<Map<String,Object>>();
  for (  String olsonId : olsonIdsToDisplay) {
    final TimeZone tz=TimeZone.getTimeZone(olsonId);
    boolean isLocalZoneId=localZoneIds.contains(olsonId);
    boolean preferLongName=isLocalZoneId && !localLongNamesAreAmbiguous;
    String displayName=getZoneDisplayName(locale,tz,now,preferLongName);
    String gmtOffsetString=DateTimeSettings.getGmtOffsetString(locale,tz);
    int offsetMillis=tz.getOffset(now.getTime());
    Map<String,Object> displayEntry=createDisplayEntry(tz,gmtOffsetString,displayName,offsetMillis);
    zones.add(displayEntry);
  }
  return zones;
}
