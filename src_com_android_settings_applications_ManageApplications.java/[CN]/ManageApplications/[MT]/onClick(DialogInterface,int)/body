{
  if (mResetDialog == dialog) {
    final PackageManager pm=getActivity().getPackageManager();
    final IPackageManager mIPm=IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
    final INotificationManager nm=INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
    final NetworkPolicyManager npm=NetworkPolicyManager.from(getActivity());
    final AppOpsManager aom=(AppOpsManager)getActivity().getSystemService(Context.APP_OPS_SERVICE);
    final Handler handler=new Handler(getActivity().getMainLooper());
    (new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        List<ApplicationInfo> apps=pm.getInstalledApplications(PackageManager.GET_DISABLED_COMPONENTS);
        for (int i=0; i < apps.size(); i++) {
          ApplicationInfo app=apps.get(i);
          try {
            if (DEBUG)             Log.v(TAG,"Enabling notifications: " + app.packageName);
            nm.setNotificationsEnabledForPackage(app.packageName,app.uid,true);
          }
 catch (          android.os.RemoteException ex) {
          }
          if (!app.enabled) {
            if (DEBUG)             Log.v(TAG,"Enabling app: " + app.packageName);
            if (pm.getApplicationEnabledSetting(app.packageName) == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER) {
              pm.setApplicationEnabledSetting(app.packageName,PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,PackageManager.DONT_KILL_APP);
            }
          }
        }
        try {
          mIPm.resetPreferredActivities(UserHandle.myUserId());
        }
 catch (        RemoteException e) {
        }
        aom.resetAllModes();
        final int[] restrictedUids=npm.getUidsWithPolicy(POLICY_REJECT_METERED_BACKGROUND);
        final int currentUserId=ActivityManager.getCurrentUser();
        for (        int uid : restrictedUids) {
          if (UserHandle.getUserId(uid) == currentUserId) {
            if (DEBUG)             Log.v(TAG,"Clearing data policy: " + uid);
            npm.setUidPolicy(uid,POLICY_NONE);
          }
        }
        handler.post(new Runnable(){
          @Override public void run(){
            if (DEBUG)             Log.v(TAG,"Done clearing");
            if (getActivity() != null && mActivityResumed) {
              if (DEBUG)               Log.v(TAG,"Updating UI!");
              for (int i=0; i < mTabs.size(); i++) {
                TabInfo tab=mTabs.get(i);
                if (tab.mApplications != null) {
                  tab.mApplications.pause();
                }
              }
              if (mCurTab != null) {
                mCurTab.resume(mSortOrder);
              }
            }
          }
        }
);
        return null;
      }
    }
).execute();
  }
}
