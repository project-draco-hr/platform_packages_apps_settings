{
  updateMenus();
  if (mStats == null || mLastDuration != mDuration) {
    load();
  }
  int[] stats;
  int statsLabel;
  if (mStatsType == MENU_TYPE_FOREGROUND) {
    stats=FOREGROUND_PROC_STATES;
    statsLabel=R.string.process_stats_type_foreground;
  }
 else   if (mStatsType == MENU_TYPE_CACHED) {
    stats=CACHED_PROC_STATES;
    statsLabel=R.string.process_stats_type_cached;
  }
 else {
    stats=mShowSystem ? BACKGROUND_AND_SYSTEM_PROC_STATES : ProcessStats.BACKGROUND_PROC_STATES;
    statsLabel=R.string.process_stats_type_background;
  }
  mAppListGroup.removeAll();
  mAppListGroup.setOrderingAsAdded(false);
  final long elapsedTime=mStats.mTimePeriodEndRealtime - mStats.mTimePeriodStartRealtime;
  long now=SystemClock.uptimeMillis();
  final PackageManager pm=getActivity().getPackageManager();
  mTotalTime=ProcessStats.dumpSingleTime(null,null,mStats.mMemFactorDurations,mStats.mMemFactor,mStats.mStartTime,now);
  if (DEBUG)   Log.d(TAG,"Total time of stats: " + makeDuration(mTotalTime));
  for (int i=0; i < mMemTimes.length; i++) {
    mMemTimes[i]=0;
  }
  for (int iscreen=0; iscreen < ProcessStats.ADJ_COUNT; iscreen+=ProcessStats.ADJ_SCREEN_MOD) {
    for (int imem=0; imem < ProcessStats.ADJ_MEM_FACTOR_COUNT; imem++) {
      int state=imem + iscreen;
      mMemTimes[imem]+=mStats.mMemFactorDurations[state];
    }
  }
  long memTotalTime;
  int[] memStates;
  LinearColorPreference colors=new LinearColorPreference(getActivity());
  colors.setOrder(-1);
switch (mMemRegion) {
case LinearColorBar.REGION_RED:
    memTotalTime=mMemTimes[ProcessStats.ADJ_MEM_FACTOR_CRITICAL];
  memStates=RED_MEM_STATES;
break;
case LinearColorBar.REGION_YELLOW:
memTotalTime=mMemTimes[ProcessStats.ADJ_MEM_FACTOR_CRITICAL] + mMemTimes[ProcessStats.ADJ_MEM_FACTOR_LOW] + mMemTimes[ProcessStats.ADJ_MEM_FACTOR_MODERATE];
memStates=YELLOW_MEM_STATES;
break;
default :
memTotalTime=mTotalTime;
memStates=ProcessStats.ALL_MEM_ADJ;
break;
}
Resources res=getResources();
colors.setColors(res.getColor(R.color.running_processes_apps_ram),res.getColor(R.color.running_processes_apps_ram),res.getColor(R.color.running_processes_free_ram));
for (int i=0; i < ProcessStats.ADJ_MEM_FACTOR_COUNT; i++) {
mMemTimes[i]=(long)((mMemTimes[i] * (double)elapsedTime) / mTotalTime);
}
ProcessStats.TotalMemoryUseCollection totalMem=new ProcessStats.TotalMemoryUseCollection(ProcessStats.ALL_SCREEN_ADJ,memStates);
mStats.computeTotalMemoryUse(totalMem,now);
double freeWeight=totalMem.sysMemFreeWeight + totalMem.sysMemCachedWeight;
double usedWeight=totalMem.sysMemKernelWeight + totalMem.sysMemNativeWeight + totalMem.sysMemZRamWeight;
double backgroundWeight=0, persBackgroundWeight=0;
mMemCachedWeight=totalMem.sysMemCachedWeight;
mMemFreeWeight=totalMem.sysMemFreeWeight;
mMemZRamWeight=totalMem.sysMemZRamWeight;
mMemKernelWeight=totalMem.sysMemKernelWeight;
mMemNativeWeight=totalMem.sysMemNativeWeight;
for (int i=0; i < ProcessStats.STATE_COUNT; i++) {
if (i == ProcessStats.STATE_SERVICE_RESTARTING) {
mMemStateWeights[i]=0;
}
 else {
mMemStateWeights[i]=totalMem.processStateWeight[i];
if (i >= ProcessStats.STATE_HOME) {
freeWeight+=totalMem.processStateWeight[i];
}
 else {
usedWeight+=totalMem.processStateWeight[i];
}
if (i >= ProcessStats.STATE_IMPORTANT_FOREGROUND) {
backgroundWeight+=totalMem.processStateWeight[i];
persBackgroundWeight+=totalMem.processStateWeight[i];
}
if (i == ProcessStats.STATE_PERSISTENT) {
persBackgroundWeight+=totalMem.processStateWeight[i];
}
}
}
if (DEBUG) {
Log.i(TAG,"Used RAM: " + Formatter.formatShortFileSize(getActivity(),(long)((usedWeight * 1024) / memTotalTime)));
Log.i(TAG,"Free RAM: " + Formatter.formatShortFileSize(getActivity(),(long)((freeWeight * 1024) / memTotalTime)));
Log.i(TAG,"Total RAM: " + Formatter.formatShortFileSize(getActivity(),(long)(((freeWeight + usedWeight) * 1024) / memTotalTime)));
Log.i(TAG,"Background+Cached RAM: " + Formatter.formatShortFileSize(getActivity(),(long)((backgroundWeight * 1024) / memTotalTime)));
}
mMemTotalWeight=freeWeight + usedWeight;
double usedRam=(usedWeight * 1024) / memTotalTime;
double freeRam=(freeWeight * 1024) / memTotalTime;
double totalRam=usedRam + freeRam;
MemInfoReader memReader=new MemInfoReader();
memReader.readMemInfo();
double realTotalRam=memReader.getTotalSize();
double totalScale=realTotalRam / totalRam;
mWeightToRam=totalScale / memTotalTime * 1024;
mMaxWeight=totalRam / mWeightToRam;
double realUsedRam=usedRam * totalScale;
double realFreeRam=freeRam * totalScale;
if (DEBUG) {
Log.i(TAG,"Scaled Used RAM: " + Formatter.formatShortFileSize(getActivity(),(long)realUsedRam));
Log.i(TAG,"Scaled Free RAM: " + Formatter.formatShortFileSize(getActivity(),(long)realFreeRam));
}
ActivityManager.MemoryInfo memInfo=new ActivityManager.MemoryInfo();
((ActivityManager)getActivity().getSystemService(Context.ACTIVITY_SERVICE)).getMemoryInfo(memInfo);
long baseCacheRam;
if (memInfo.hiddenAppThreshold >= realFreeRam) {
realUsedRam=realFreeRam;
realFreeRam=0;
baseCacheRam=(long)realFreeRam;
}
 else {
realUsedRam+=memInfo.hiddenAppThreshold;
realFreeRam-=memInfo.hiddenAppThreshold;
baseCacheRam=memInfo.hiddenAppThreshold;
}
if (DEBUG) {
Log.i(TAG,"Adj Scaled Used RAM: " + Formatter.formatShortFileSize(getActivity(),(long)realUsedRam));
Log.i(TAG,"Adj Scaled Free RAM: " + Formatter.formatShortFileSize(getActivity(),(long)realFreeRam));
}
mMemStatusPref.setOrder(-2);
mAppListGroup.addPreference(mMemStatusPref);
String durationString=Utils.formatElapsedTime(getActivity(),elapsedTime,false);
String usedString=Formatter.formatShortFileSize(getActivity(),(long)realUsedRam);
String totalString=Formatter.formatShortFileSize(getActivity(),(long)realTotalRam);
CharSequence memString;
CharSequence[] memStatesStr=getResources().getTextArray(R.array.ram_states);
if (mMemState >= 0 && mMemState < memStatesStr.length) {
memString=memStatesStr[mMemState];
}
 else {
memString="?";
}
mMemStatusPref.setTitle(getActivity().getString(R.string.process_stats_total_duration,usedString,totalString,durationString));
mMemStatusPref.setSummary(getActivity().getString(R.string.process_stats_memory_status,memString));
float usedRatio=(float)(realUsedRam / (realFreeRam + realUsedRam));
colors.setRatios(usedRatio,0,1 - usedRatio);
if (false) {
colors.setOnRegionTappedListener(this);
switch (mMemRegion) {
case LinearColorBar.REGION_RED:
colors.setColoredRegions(LinearColorBar.REGION_RED);
memTotalTime=mMemTimes[ProcessStats.ADJ_MEM_FACTOR_CRITICAL];
memStates=RED_MEM_STATES;
break;
case LinearColorBar.REGION_YELLOW:
colors.setColoredRegions(LinearColorBar.REGION_RED | LinearColorBar.REGION_YELLOW);
memTotalTime=mMemTimes[ProcessStats.ADJ_MEM_FACTOR_CRITICAL] + mMemTimes[ProcessStats.ADJ_MEM_FACTOR_LOW] + mMemTimes[ProcessStats.ADJ_MEM_FACTOR_MODERATE];
memStates=YELLOW_MEM_STATES;
break;
default :
colors.setColoredRegions(LinearColorBar.REGION_ALL);
memTotalTime=mTotalTime;
memStates=ProcessStats.ALL_MEM_ADJ;
break;
}
colors.setRatios(mMemTimes[ProcessStats.ADJ_MEM_FACTOR_CRITICAL] / (float)mTotalTime,(mMemTimes[ProcessStats.ADJ_MEM_FACTOR_LOW] + mMemTimes[ProcessStats.ADJ_MEM_FACTOR_MODERATE]) / (float)mTotalTime,mMemTimes[ProcessStats.ADJ_MEM_FACTOR_NORMAL] / (float)mTotalTime);
}
mAppListGroup.addPreference(colors);
ProcessStats.ProcessDataCollection bgTotals=new ProcessStats.ProcessDataCollection(ProcessStats.ALL_SCREEN_ADJ,memStates,stats);
ProcessStats.ProcessDataCollection runTotals=new ProcessStats.ProcessDataCollection(ProcessStats.ALL_SCREEN_ADJ,memStates,ProcessStats.NON_CACHED_PROC_STATES);
final ArrayList<ProcStatsEntry> procEntries=new ArrayList<>();
final ArrayList<ProcStatsPackageEntry> pkgEntries=new ArrayList<>();
if (DEBUG) Log.d(TAG,"-------------------- PULLING PROCESSES");
final ProcessMap<ProcStatsEntry> entriesMap=new ProcessMap<ProcStatsEntry>();
for (int ipkg=0, N=mStats.mPackages.getMap().size(); ipkg < N; ipkg++) {
final SparseArray<SparseArray<ProcessStats.PackageState>> pkgUids=mStats.mPackages.getMap().valueAt(ipkg);
for (int iu=0; iu < pkgUids.size(); iu++) {
final SparseArray<ProcessStats.PackageState> vpkgs=pkgUids.valueAt(iu);
for (int iv=0; iv < vpkgs.size(); iv++) {
final ProcessStats.PackageState st=vpkgs.valueAt(iv);
for (int iproc=0; iproc < st.mProcesses.size(); iproc++) {
final ProcessStats.ProcessState pkgProc=st.mProcesses.valueAt(iproc);
final ProcessStats.ProcessState proc=mStats.mProcesses.get(pkgProc.mName,pkgProc.mUid);
if (proc == null) {
Log.w(TAG,"No process found for pkg " + st.mPackageName + "/"+ st.mUid+ " proc name "+ pkgProc.mName);
continue;
}
ProcStatsEntry ent=entriesMap.get(proc.mName,proc.mUid);
if (ent == null) {
ent=new ProcStatsEntry(proc,st.mPackageName,bgTotals,runTotals,mUseUss);
if (ent.mRunWeight > 0) {
if (DEBUG) Log.d(TAG,"Adding proc " + proc.mName + "/"+ proc.mUid+ ": time="+ makeDuration(ent.mRunDuration)+ " ("+ ((((double)ent.mRunDuration) / memTotalTime) * 100)+ "%)"+ " pss="+ ent.mAvgRunMem);
entriesMap.put(proc.mName,proc.mUid,ent);
procEntries.add(ent);
}
}
 else {
ent.addPackage(st.mPackageName);
}
}
}
}
}
if (DEBUG) Log.d(TAG,"-------------------- MAPPING SERVICES");
if (mStatsType == MENU_TYPE_BACKGROUND) {
for (int ip=0, N=mStats.mPackages.getMap().size(); ip < N; ip++) {
SparseArray<SparseArray<ProcessStats.PackageState>> uids=mStats.mPackages.getMap().valueAt(ip);
for (int iu=0; iu < uids.size(); iu++) {
SparseArray<ProcessStats.PackageState> vpkgs=uids.valueAt(iu);
for (int iv=0; iv < vpkgs.size(); iv++) {
ProcessStats.PackageState ps=vpkgs.valueAt(iv);
for (int is=0, NS=ps.mServices.size(); is < NS; is++) {
ProcessStats.ServiceState ss=ps.mServices.valueAt(is);
if (ss.mProcessName != null) {
ProcStatsEntry ent=entriesMap.get(ss.mProcessName,uids.keyAt(iu));
if (ent != null) {
if (DEBUG) Log.d(TAG,"Adding service " + ps.mPackageName + "/"+ ss.mName+ "/"+ uids.keyAt(iu)+ " to proc "+ ss.mProcessName);
ent.addService(ss);
}
 else {
Log.w(TAG,"No process " + ss.mProcessName + "/"+ uids.keyAt(iu)+ " for service "+ ss.mName);
}
}
}
}
}
}
}
HashMap<String,ProcStatsPackageEntry> pkgMap=new HashMap<>();
for (int i=procEntries.size() - 1; i >= 0; i--) {
ProcStatsEntry proc=procEntries.get(i);
proc.evaluateTargetPackage(pm,mStats,bgTotals,runTotals,sEntryCompare,mUseUss);
ProcStatsPackageEntry pkg=pkgMap.get(proc.mBestTargetPackage);
if (pkg == null) {
pkg=new ProcStatsPackageEntry(proc.mBestTargetPackage);
pkgMap.put(proc.mBestTargetPackage,pkg);
pkgEntries.add(pkg);
}
pkg.addEntry(proc);
}
ProcStatsPackageEntry osPkg=new ProcStatsPackageEntry("os");
pkgMap.put("os",osPkg);
pkgEntries.add(osPkg);
ProcStatsEntry osEntry;
if (totalMem.sysMemNativeWeight > 0) {
osEntry=new ProcStatsEntry("os",0,getString(R.string.process_stats_os_native),memTotalTime,(long)(totalMem.sysMemNativeWeight / memTotalTime));
osEntry.evaluateTargetPackage(pm,mStats,bgTotals,runTotals,sEntryCompare,mUseUss);
osPkg.addEntry(osEntry);
}
if (totalMem.sysMemKernelWeight > 0) {
osEntry=new ProcStatsEntry("os",0,getString(R.string.process_stats_os_kernel),memTotalTime,(long)(totalMem.sysMemKernelWeight / memTotalTime));
osEntry.evaluateTargetPackage(pm,mStats,bgTotals,runTotals,sEntryCompare,mUseUss);
osPkg.addEntry(osEntry);
}
if (totalMem.sysMemZRamWeight > 0) {
osEntry=new ProcStatsEntry("os",0,getString(R.string.process_stats_os_zram),memTotalTime,(long)(totalMem.sysMemZRamWeight / memTotalTime));
osEntry.evaluateTargetPackage(pm,mStats,bgTotals,runTotals,sEntryCompare,mUseUss);
osPkg.addEntry(osEntry);
}
if (baseCacheRam > 0) {
osEntry=new ProcStatsEntry("os",0,getString(R.string.process_stats_os_cache),memTotalTime,baseCacheRam / 1024);
osEntry.evaluateTargetPackage(pm,mStats,bgTotals,runTotals,sEntryCompare,mUseUss);
osPkg.addEntry(osEntry);
}
for (int i=0, N=pkgEntries.size(); i < N; i++) {
ProcStatsPackageEntry pkg=pkgEntries.get(i);
pkg.updateMetrics();
}
Collections.sort(pkgEntries,sPackageEntryCompare);
if (DEBUG) Log.d(TAG,"-------------------- BUILDING UI");
int end=pkgEntries.size() - 1;
while (end >= 0) {
ProcStatsPackageEntry pkg=pkgEntries.get(end);
final double percentOfWeight=(pkg.mRunWeight / mMaxWeight) * 100;
final double percentOfTime=(((double)pkg.mRunDuration) / memTotalTime) * 100;
if (percentOfWeight >= .01 || percentOfTime >= 25) {
break;
}
end--;
}
for (int i=0; i <= end; i++) {
ProcStatsPackageEntry pkg=pkgEntries.get(i);
final double percentOfWeight=(pkg.mRunWeight / mMaxWeight) * 100;
final double percentOfTime=(((double)pkg.mRunDuration) / memTotalTime) * 100;
ProcessStatsPreference pref=new ProcessStatsPreference(getActivity());
pref.init(null,pkg);
pkg.retrieveUiData(getActivity(),pm);
pref.setTitle(pkg.mUiLabel);
if (pkg.mUiTargetApp != null) {
pref.setIcon(pkg.mUiTargetApp.loadIcon(pm));
}
pref.setOrder(i);
pref.setPercent(percentOfWeight,percentOfTime,(long)(pkg.mRunWeight * mWeightToRam));
mAppListGroup.addPreference(pref);
if (mStatsType == MENU_TYPE_BACKGROUND) {
if (DEBUG) {
Log.i(TAG,"App " + pkg.mUiLabel + ": weightedRam="+ Formatter.formatShortFileSize(getActivity(),(long)((pkg.mRunWeight * 1024) / memTotalTime))+ ", avgRam="+ Formatter.formatShortFileSize(getActivity(),(pkg.mAvgRunMem * 1024)));
}
}
if (mAppListGroup.getPreferenceCount() > (MAX_ITEMS_TO_LIST + 1)) {
if (DEBUG) Log.d(TAG,"Done with UI, hit item limit!");
break;
}
}
}
