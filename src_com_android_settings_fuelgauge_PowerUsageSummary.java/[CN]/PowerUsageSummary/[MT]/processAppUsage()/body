{
  SensorManager sensorManager=(SensorManager)getSystemService(Context.SENSOR_SERVICE);
  final int which=mStatsType;
  final int speedSteps=mPowerProfile.getNumSpeedSteps();
  final double[] powerCpuNormal=new double[speedSteps];
  final long[] cpuSpeedStepTimes=new long[speedSteps];
  for (int p=0; p < speedSteps; p++) {
    powerCpuNormal[p]=mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE,p);
  }
  final double averageCostPerByte=getAverageDataCost();
  long uSecTime=mStats.computeBatteryRealtime(SystemClock.elapsedRealtime() * 1000,which);
  mStatsPeriod=uSecTime;
  updateStatsPeriod(uSecTime);
  SparseArray<? extends Uid> uidStats=mStats.getUidStats();
  final int NU=uidStats.size();
  for (int iu=0; iu < NU; iu++) {
    Uid u=uidStats.valueAt(iu);
    double power=0;
    double highestDrain=0;
    String packageWithHighestDrain=null;
    Map<String,? extends BatteryStats.Uid.Proc> processStats=u.getProcessStats();
    long cpuTime=0;
    long cpuFgTime=0;
    long wakelockTime=0;
    long gpsTime=0;
    if (processStats.size() > 0) {
      for (      Map.Entry<String,? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
        if (DEBUG)         Log.i(TAG,"Process name = " + ent.getKey());
        Uid.Proc ps=ent.getValue();
        final long userTime=ps.getUserTime(which);
        final long systemTime=ps.getSystemTime(which);
        final long foregroundTime=ps.getForegroundTime(which);
        cpuFgTime+=foregroundTime * 10;
        final long tmpCpuTime=(userTime + systemTime) * 10;
        int totalTimeAtSpeeds=0;
        for (int step=0; step < speedSteps; step++) {
          cpuSpeedStepTimes[step]=ps.getTimeAtCpuSpeedStep(step,which);
          totalTimeAtSpeeds+=cpuSpeedStepTimes[step];
        }
        if (totalTimeAtSpeeds == 0)         totalTimeAtSpeeds=1;
        double processPower=0;
        for (int step=0; step < speedSteps; step++) {
          double ratio=(double)cpuSpeedStepTimes[step] / totalTimeAtSpeeds;
          processPower+=ratio * tmpCpuTime * powerCpuNormal[step];
        }
        cpuTime+=tmpCpuTime;
        power+=processPower;
        if (highestDrain < processPower) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
      }
      if (DEBUG)       Log.i(TAG,"Max drain of " + highestDrain + " by "+ packageWithHighestDrain);
    }
    if (cpuFgTime > cpuTime) {
      if (DEBUG && cpuFgTime > cpuTime + 10000) {
        Log.i(TAG,"WARNING! Cputime is more than 10 seconds behind Foreground time");
      }
      cpuTime=cpuFgTime;
    }
    power/=1000;
    Map<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
    for (    Map.Entry<String,? extends BatteryStats.Uid.Wakelock> wakelockEntry : wakelockStats.entrySet()) {
      Uid.Wakelock wakelock=wakelockEntry.getValue();
      BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
      if (timer != null) {
        wakelockTime+=timer.getTotalTimeLocked(uSecTime,which);
      }
    }
    wakelockTime/=1000;
    long tcpBytesReceived=u.getTcpBytesReceived(mStatsType);
    long tcpBytesSent=u.getTcpBytesSent(mStatsType);
    power+=(tcpBytesReceived + tcpBytesSent) * averageCostPerByte;
    long wifiRunningTimeMs=u.getWifiRunningTime(uSecTime,which) / 1000;
    mAppWifiRunning+=wifiRunningTimeMs;
    power+=(wifiRunningTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_ON)) / 1000;
    Map<Integer,? extends BatteryStats.Uid.Sensor> sensorStats=u.getSensorStats();
    for (    Map.Entry<Integer,? extends BatteryStats.Uid.Sensor> sensorEntry : sensorStats.entrySet()) {
      Uid.Sensor sensor=sensorEntry.getValue();
      int sensorType=sensor.getHandle();
      BatteryStats.Timer timer=sensor.getSensorTime();
      long sensorTime=timer.getTotalTimeLocked(uSecTime,which) / 1000;
      double multiplier=0;
switch (sensorType) {
case Uid.Sensor.GPS:
        multiplier=mPowerProfile.getAveragePower(PowerProfile.POWER_GPS_ON);
      gpsTime=sensorTime;
    break;
default :
  android.hardware.Sensor sensorData=sensorManager.getDefaultSensor(sensorType);
if (sensorData != null) {
  multiplier=sensorData.getPower();
  if (DEBUG) {
    Log.i(TAG,"Got sensor " + sensorData.getName() + " with power = "+ multiplier);
  }
}
}
power+=(multiplier * sensorTime) / 1000;
}
if (DEBUG) Log.i(TAG,"UID " + u.getUid() + ": power="+ power);
if (power != 0) {
BatterySipper app=new BatterySipper(this,mRequestQueue,mHandler,packageWithHighestDrain,DrainType.APP,0,u,new double[]{power});
app.cpuTime=cpuTime;
app.gpsTime=gpsTime;
app.wifiRunningTime=wifiRunningTimeMs;
app.cpuFgTime=cpuFgTime;
app.wakeLockTime=wakelockTime;
app.tcpBytesReceived=tcpBytesReceived;
app.tcpBytesSent=tcpBytesSent;
if (u.getUid() == Process.WIFI_UID) {
mWifiSippers.add(app);
}
 else {
mUsageList.add(app);
}
}
if (u.getUid() == Process.WIFI_UID) {
mWifiPower+=power;
}
 else {
if (power > mMaxPower) mMaxPower=power;
mTotalPower+=power;
}
if (DEBUG) Log.i(TAG,"Added power = " + power);
}
}
