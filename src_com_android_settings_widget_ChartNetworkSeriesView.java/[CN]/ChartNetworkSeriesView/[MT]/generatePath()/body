{
  if (LOGD)   Log.d(TAG,"generatePath()");
  mMax=0;
  mPathStroke.reset();
  mPathFill.reset();
  mPathEstimate.reset();
  if (mStats == null || mStats.size() < 2)   return;
  final int width=getWidth();
  final int height=getHeight();
  boolean started=false;
  float firstX=0;
  float lastX=0;
  float lastY=0;
  long lastTime=Long.MIN_VALUE;
  long totalData=0;
  NetworkStatsHistory.Entry entry=null;
  for (int i=0; i < mStats.size(); i++) {
    entry=mStats.getValues(i,entry);
    lastTime=entry.bucketStart + entry.bucketDuration;
    final float x=mHoriz.convertToPoint(lastTime);
    final float y=mVert.convertToPoint(totalData);
    if (i > 0 && !started && x > 0) {
      mPathStroke.moveTo(lastX,lastY);
      mPathFill.moveTo(lastX,lastY);
      started=true;
      firstX=x;
    }
    if (started) {
      mPathStroke.lineTo(x,y);
      mPathFill.lineTo(x,y);
      totalData+=entry.rxBytes + entry.txBytes;
    }
    if (x > width)     break;
    lastX=x;
    lastY=y;
  }
  if (lastTime < mEndTime) {
    lastX=mHoriz.convertToPoint(mEndTime);
    if (started) {
      mPathStroke.lineTo(lastX,lastY);
      mPathFill.lineTo(lastX,lastY);
    }
  }
  if (LOGD) {
    final RectF bounds=new RectF();
    mPathFill.computeBounds(bounds,true);
    Log.d(TAG,"onLayout() rendered with bounds=" + bounds.toString() + " and totalData="+ totalData);
  }
  mPathFill.lineTo(lastX,height);
  mPathFill.lineTo(firstX,height);
  mMax=totalData;
  mPathEstimate.moveTo(lastX,lastY);
  final long now=System.currentTimeMillis();
  final long bucketDuration=mStats.getBucketDuration();
  entry=mStats.getValues(lastTime - WEEK_IN_MILLIS * 2,lastTime,now,entry);
  final long longWindow=(entry.rxBytes + entry.txBytes) * bucketDuration / entry.bucketDuration;
  long futureTime=0;
  while (lastX < width) {
    futureTime+=bucketDuration;
    final long lastWeekTime=lastTime - WEEK_IN_MILLIS + (futureTime % WEEK_IN_MILLIS);
    entry=mStats.getValues(lastWeekTime - DAY_IN_MILLIS,lastWeekTime,now,entry);
    final long shortWindow=(entry.rxBytes + entry.txBytes) * bucketDuration / entry.bucketDuration;
    totalData+=(longWindow * 7 + shortWindow * 3) / 10;
    lastX=mHoriz.convertToPoint(lastTime + futureTime);
    lastY=mVert.convertToPoint(totalData);
    mPathEstimate.lineTo(lastX,lastY);
  }
  mMaxEstimate=totalData;
}
